#!/usr/bin/env python3
"""TBD"""
# pylint: disable=invalid-name,too-many-branches,too-many-locals
# pylint: disable=too-many-nested-blocks,import-outside-toplevel

import os
import sys
from types import SimpleNamespace
import heapq

##############################################################################
##   human()
##############################################################################
def human(number):
    """ Return a concise number description."""
    suffixes = ['K', 'M', 'G', 'T']
    while suffixes:
        suffix = suffixes.pop(0)
        number /= 1024
        if number < 99.95 or not suffixes:
            return f'{number:.1f}{suffix}'
    return '???' # should not happen

class Scorer:
    """Class for doing scoring computations"""
    scorer = None
    letters = {} # info on each letter
    grand_uniq_cnt = 0 # grand total of unique letters in words
    max_uniq_cnt = 0
    word_cnt = 0  # of answers

    def __init__(self):
        for letter in list('abcdefghijklmnopqrstuvwxyz'):
            self.letters[letter] = SimpleNamespace(
                    letter=letter,
                    pos_cnts=[0, 0, 0, 0, 0],
                    pos_mults=[0, 0, 0, 0, 0],
                    pos_sum=0,
                    uniq_cnt=0
                )

    @staticmethod
    def get_singleton():
        """TBD"""
        if not Scorer.scorer:
            Scorer.scorer = Scorer()
        return Scorer.scorer

    def add_word(self, word):
        """ Add a word to the scoring database."""
        seen = set()
        for pos, letter in enumerate(list(word)):
            ns = self.letters[letter]
            ns.pos_cnts[pos] += 1
            ns.pos_sum += 1
            if letter not in seen:
                seen.add(letter)
                ns.uniq_cnt += 1
                Scorer.grand_uniq_cnt += 1
        self.word_cnt += 1

    def freeze(self, exponent):
        """ Finish off scoring params. """
        Scorer.max_uniq_cnt = 0
        for ns in self.letters.values():
            if Scorer.max_uniq_cnt < ns.uniq_cnt:
                Scorer.max_uniq_cnt = ns.uniq_cnt
            for pos in range(5):
                mult = (ns.pos_cnts[pos] * 5) / ns.pos_sum
                # take a root to compress numbers if <1 (default=0.33)
                mult = round(mult ** exponent, 2)
                ns.pos_mults[pos] = mult

    def get_scores(self, word):
        """Get basic scord of word which is how many letters
        the work reveals"""
        raw_score = 0
        adj_score = 0
        for pos, letter in enumerate(list(word)):
            ns = self.letters[letter]
            score = int(round(1000*ns.uniq_cnt/Scorer.grand_uniq_cnt))
            raw_score += score
            ### give bonus for less popular letters
            ## score *= (2*Scorer.max_uniq_cnt - ns.uniq_cnt)/Scorer.max_uniq_cnt
            # give bonus for right position
            score *= ns.pos_mults[pos]
            adj_score += score

        return int(round(adj_score)), raw_score

    def dump(self, verbose):
        """Show the scoring stats"""
        print(f'{self.word_cnt} answer words; {Scorer.grand_uniq_cnt} unique letters')
        print('Showing for each letter:')
        print(' - % of all words w letter')
        print(' - % of words w letter having it in position (>100% reflects double-letters)')

        print('\nlet  pct   1  2  3  4  5  sum [position-pcts]')
        print(  '=== ====  == == == == ==  ===')

        nses = sorted(self.letters.values(), key= lambda ns: ns.uniq_cnt, reverse=True)
        for ns in nses:
            pcts = [int(round((100*cnt)/ns.uniq_cnt)) for cnt in ns.pos_cnts]
            pct_strs = [f'{pct:2d}' for pct in pcts]

            mults = [f'{mult:4.2f}' for mult in ns.pos_mults]
            mults_str = ' '.join(mults)
            out = f' {ns.letter}: {(100*ns.uniq_cnt)//Scorer.grand_uniq_cnt:3.1f}%'
            out += f'  {" ".join(pct_strs)} = {sum(pcts):3d}'
            if verbose:
                out += f'mults: {mults_str}'
            print(out)


class BestWords:
    """TBD"""
    def __init__(self):
        self.here = os.path.dirname(os.path.abspath(__file__)) # source directory
        self.opts = None
        self.answers = None
        self.guesses = None
        self.complexs = {} # keyed by vowel string


    def get_word_lists(self, opts):
        """Read the word lists"""
        self.opts = opts
        self.answers = self._get_words(os.path.join(self.here, 'answers.txt'))
        self.guesses = self._get_words(os.path.join(self.here,'legal_words.txt'))
        self.guesses.update(self.answers)

    @staticmethod
    def overlapped(a, b):
        """Returns whether there is an overlap of two words."""
        return len(set(list(a) + list(b))) != len(a) + len(b)

    @staticmethod
    def get_overlap(a, b):
        """ number of overlapping letters in two words. """
        return len(set(list(a)) & set(list(b)))
        #rv = 0
        #for char in a:
            #if char in b:
                #rv += 1
        #return rv

    def _get_words(self, file_path):
        """This reads a set of words in a file into a list of words
        and into a set words (either the set of answers or legal guess)
        """
        words = {}
        scorer = Scorer.get_singleton() if 'answers' in file_path else None

        with open(file_path, "r", encoding='utf-8') as file:
            file_contents = file.read()
            lines = file_contents.splitlines()
            for line in lines:
                line = line.strip()
                if not line.startswith('#'):
                    wds = line.split()
                    for wd in wds:
                        words[wd] = None
                        if scorer:
                            scorer.add_word(wd)
        if self.opts.verbose:
            print(f'#words = {len(words)} in {file_path}')
        if scorer:
            scorer.freeze(exponent=self.opts.exponent)
        return words

    def _get_germs(self, file_path):
        """This reads a set of words in a file into a list of words
        and into a set "germs" (or digests) that has the letters
        sorted and dups removed.  It also counts the number of
        letters used by all the words."""
        words = []
        germs = {}
        scorer = Scorer.get_singleton() if 'answers' in file_path else None

        with open(file_path, "r", encoding='utf-8') as file:
            file_contents = file.read()
            lines = file_contents.splitlines()
            for line in lines:
                line = line.strip()
                if not line.startswith('#'):
                    words += line.split()
        print(f'#words = {len(words)}')

        for word in words:
            if scorer:
                scorer.add_word(word)

            germ = set(list(word))
            germ = sorted(germ)
            germ = ''.join(germ)
            if germ in germs:
                germs[germ].append(word)
            else:
                germs[germ] = [word]
        print(f'#germs = {len(germs)}')
        return germs

    @staticmethod
    def store_top(results, item):
        """ This will store the top 30 items in a set of items. """
        if len(results) < 30:
            heapq.heappush(results, item)
        else:
            heapq.heappushpop(results, item)

    def get_some_fours(self, keys_str):
        """TBD"""
        def get_scores(found):
            nonlocal self, scorer, keys_str
            scores = [0]*8
            words = found.split()
            adj_score, raw_score = 0, 0
            used_letters = set()
            for idx, word in enumerate(words):
                subword = ''
                for letter in list(word):
                    if letter not in used_letters:
                        subword += letter
                        used_letters.add(letter)
                adj, raw = scorer.get_scores(subword)
                adj_score += adj
                raw_score += raw

                scores[idx] = adj_score
                scores[idx+4] = raw_score

            return (int(0.20*scores[0]
                    + 0.20*scores[1]
                    + 0.20*scores[2]
                    + 0.40*scores[3]),
                    scores, found, keys_str)

        scorer = Scorer.get_singleton()
        keys = keys_str.split('-')
        assert len(keys) == 4

        # get the lists of candidate words .. one word list
        # for each of the vowel clusters. Words must:
        #   - have all the vowels in the cluster and no more vowels
        #   - have 5 unique letters
        # If there are enough words drawing only from the answers,
        # then use those; else draw from the legal guesses.
        lists = [[], [], [], []]
        for idx, key in enumerate(keys):
            if len(key) == 5:
                # if the word is fully specified, accept it
                lists[idx] = [key]
                continue
            # only vowels in keys allowed (if not full word)
            assert self.get_overlap(key, "aeiouy") == len(key)
            for word_dict in (self.answers, self.guesses):
                words = []
                for word in word_dict:
                    if len(set(list(word))) != 5:
                        continue
                    if self.get_overlap(key, word) != len(key):
                        continue
                    if self.get_overlap('aeiouy', word) != len(key):
                        continue
                    words.append(word)
                lists[idx] = words
                # print(f'{idx} {key} #{len(words)}')
                if len(words) >= 100:
                    break
                
        cnts = [len(words) for words in lists]
        loops = cnts[0]*cnts[1]*cnts[2]*cnts[3]
        cnts_str = 'x'.join(str(cnt) for cnt in cnts)
        self.complexs[keys_str] = f'{cnts_str}={human(loops)}'

        rv = []
        least_overlap = 1000
        last_pct = 0
        loops = len(lists[0])
        for idx, word0 in enumerate(lists[0]):
            for word1 in lists[1]:
                if self.overlapped(word0, word1):
                    continue
                for word2 in lists[2]:
                    if self.overlapped(word0+word1, word2):
                        continue
                    for word3 in lists[3]:
                        lap = self.get_overlap(word0+word1+word2, word3)
                        if lap > least_overlap:
                            continue
                        if lap < least_overlap:
                            if least_overlap > 2:
                                rv = []
                            least_overlap = lap
                        found = f'{word0} {word1} {word2} {word3}'
                        scores = get_scores(found)
                        self.store_top(rv, scores)
            pct = int(100*idx/loops)
            if pct > last_pct:
                # print(f'{pct}%')
                last_pct = pct
        return sorted(rv)

    def main(self):
        """TBD"""
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument('-x', '--exponent', default=2.0, type=float,
                help='value to favor letter in right slot [def=2, min=0, max=4]')
        parser.add_argument('-p', '--pick', default='',
                            help='substring to match vowel sets')
        parser.add_argument('-k', '--keys', type=str, default='',
                            help="specify a-b-c-d to try")
        parser.add_argument('-e', '--every', action='store_true',
                            help='do every vowel set, not just priorities')
        parser.add_argument('-s', '--stats-only', action='store_true',
                            help='show words stats only')
        parser.add_argument('-v', '--verbose', action='store_true',
                            help='show detail / debugging info')
        
        sys.stdout.reconfigure(line_buffering=True)

        self.get_word_lists(parser.parse_args())
        if self.opts.exponent > 2.0:
            self.opts.exponent = 2.0
        elif self.opts.exponent < 0.0:
            self.opts.exponent = 0.0
            
        if self.opts.keys:
            keys = self.opts.keys.split('-')
            assert len(keys) == 4
            for key in keys:
                assert len(key) > 0, (f'key ({repr(key)} of'
                      f' {repr(self.opts.keys)}) should not be empty')

        if self.opts.verbose:
            Scorer.get_singleton().dump(self.opts.verbose)
        if self.opts.stats_only:
            return

        whichs = [
                # These are the sets of vowels we try
                # - the second value is whether "priority"
                #   or a contender (for -x2)
            ('a-e-i-ouy', False), #
            ('a-e-ui-oy', False), #
            ('a-ei-oy-u', False), #
            ('a-ei-uy-o', False), # 2730
            ('a-ei-o-uy', False), #
            ('a-ue-iy-o', False), #
            ('a-ue-iy-o', False), #
            ('ae-iy-u-o', False), # 2787
            ('ae-i-oy-u', False), #
            ('ae-iu-y-o', False), #
            ('ae-io-y-u', False), #
            ('aei-o-y-u', False), #
            ('e-a-iy-ou', False), #
            ('e-ai-uy-o', False), #
            ('e-ai-oy-u', False), #
            ('ei-a-oy-u', False), #
            ('ei-a-uy-o', False), #
            ('ei-a-o-uy', False), #
            ('eo-ai-y-u', False), #
            ('iy-a-o-ue', True), # 2902
            ('iy-o-a-ue', True), # 2879
            ('o-iy-ue-a', False), #
            ('ou-ae-i-y', False), #
            ('oy-ai-u-e', True), # 
            ('oy-i-a-ue', True), # 2877
            ('oe-y-i-au', False), #
            ('ue-i-a-oy', False), #
            (None, True) # None forces final results
        ]
        bests = []
        # this loop prints out a summary for each of the vowel sets
        # and then the top 30 overall scores
        if self.opts.keys:
            whichs = [(self.opts.keys, True), (None, True)]
            
        for keys, priority in whichs:
            doit = priority
            if keys is None or self.opts.every:
                doit = True
            elif self.opts.pick:
                doit = bool(self.opts.pick in keys)
            if doit:
                rvs = self.get_some_fours(keys) if keys else sorted(bests)
                complexity = self.complexs.get(keys, '')
                if len(rvs) < 1:
                    print(f'\n====== {keys} NONE')
                    continue

                print(f'\n====== {keys} range={rvs[0][0]}-{rvs[-1][0]}'
                      + (' complexity: ' if complexity else '') + complexity)
                for rv in rvs:
                    if keys:
                        self.store_top(bests, rv)
                        if not self.opts.verbose:
                            continue
                    total, scores, words, keys_str = rv
                    uniq = set(list(''.join(words.split()))) # #uniq letters
                    all = set(list('abcdefghijklmnopqrstuvwxyz')) # #uniq letters
                    left = '/' + ''.join(sorted(list(all - uniq)))
                    print(rv[0],
                        str(scores[0:4]) if self.opts.verbose else '',
                        scores[4:], words, left, keys_str)

obj = BestWords()
obj.main()
