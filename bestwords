#!/usr/bin/env python3

import os
import heapq

class BestWords:

    def __init__(self):
        here = os.path.dirname(os.path.abspath(__file__)) # source directory
        self.total_letters = 0
        self.short_minis = self._get_minis(os.path.join(here, 'answers.txt'))
        self.total_short, self.total_letters = self.total_letters, 0
        self.minis = self._get_minis(os.path.join(here,'legal_words.txt'))
        for mini, values in self.short_minis.items():
            if mini in self.minis:
                self.minis[mini] += values
            else:
                self.minis[mini] = values
        self.total_letters += self.total_short
        self.uniq_minis = [mini for mini in self.minis if len(mini)==5]
        self.uniq_shorts = [mini for mini in self.short_minis if len(mini)==5]
        print(f'#uniq = {len(self.uniq_minis)}')

    @staticmethod
    def overlapped(a, b):
        """Returns whether there is an overlap of two words."""
        return len(set(list(a) + list(b))) != len(a) + len(b)

    @staticmethod
    def get_overlap(a, b):
        """ number of overlapping letters in two words. """
        rv = 0
        for char in a:
            if char in b:
                rv += 1
        return rv

    def _get_minis(self, file_path):
        """This reads a set of words in a file into a list of words
        and into a set "minis" (or digests) that has the letters
        sorted and dups removed.  It also counts the number of
        letters used by all the words."""
        words = []
        minis = {}

        with open(file_path, "r") as file:
            file_contents = file.read()
            lines = file_contents.splitlines()
            for line in lines:
                line = line.strip()
                if not line.startswith('#'):
                    words += line.split()
        print(f'#words = {len(words)}')

        for word in words:
            mini = set(list(word))
            mini = sorted(mini)
            mini = ''.join(mini)
            if mini in minis:
                minis[mini].append(word)
            else:
                minis[mini] = [word]
            self.total_letters += len(mini)
        print(f'#minis = {len(minis)}')
        total_letters = 5*len(minis)
        return(minis)


    @staticmethod
    def store_top(results, item):
        """ This will store the top 30 items in a set of items. """
        if len(results) < 30:
            heapq.heappush(results, item)
        else:
            heapq.heappushpop(results, item)


    def get_some_fours(self, which):
        def get_scores(found):
            nonlocal self
            scores = []
            words = found.split()
            score = 0
            for word in words:
                for mini in self.short_minis:
                    score += self.get_overlap(word, mini)
                scores.append(int(1000*score/self.total_short))
                
            return (scores[1]+scores[2]+scores[3], scores, found)

        rv = []
        groups = [[], [], [], []]

        # get all the possible sets of four words given the group of vowels
        # and the word set chosen. the 4 words will cover 20 letters because
        # each word must have 5 unique letters and use letters not covered
        # by the preceding words.
        for i, word_dict in enumerate((self.uniq_shorts, self.uniq_minis)):
            for mini in word_dict:
                vowels = ''.join(sorted(set(mini).intersection(set('aeiouy'))))
                pair = which.get(vowels, None)
                if pair and i == pair[0]:
                    groups[pair[1]].append(mini)
        for group in groups:
            print(f'#{len(group)} {group[0:10]}')

        for mini0 in groups[0]:
            for mini1 in groups[1]:
                if self.overlapped(mini0, mini1):
                    continue
                for mini2 in groups[2]:
                    if self.overlapped(mini0+mini1, mini2):
                        continue
                    for mini3 in groups[3]:
                        if self.overlapped(mini0+mini1+mini2, mini3):
                            continue
                        found = f'{mini0} {mini1} {mini2} {mini3}'
                        scores = get_scores(found)
                        self.store_top(rv, scores)
        return sorted(rv)

    def main(self):

        whichs = [
                # These are the sets of vowels we try
                # - the vowels must be alpabetical in each group/key
                # - the value is a tuple:
                #   - 0 means use legal answers; 1 means use legal guesses
                #   - 0,1,2,3 are the guess numbers 
            { 'ae': (0, 0) ,'iu': (0, 1) ,'y': (1, 2) ,'o': (1, 3) },
            { 'ae': (0, 0) ,'io': (0, 1) ,'y': (1, 2) ,'u': (1, 3) },
            { 'aei': (1, 0) ,'o': (0, 1) ,'y': (1, 2) ,'u': (1, 3) },
            { 'eo': (0, 0) ,'ai': (0, 1) ,'y': (1, 2) ,'u': (1, 3) },
            { 'e': (0, 0) ,'a': (0, 1) ,'iy': (1, 2) ,'ou': (1, 3) },
        ]
        bests = []
        # this loop prints out the top 30 for each vowel set above,
        # and then the top 30 overall
        for which in whichs + [None]:
            rvs = self.get_some_fours(which) if which else sorted(bests)
            print(f'\n====== {which}')
            for rv in rvs:
                minis = rv[2].split()
                print(rv[0], rv[1], self.minis[minis[0]],
                    self.minis[minis[1]], self.minis[minis[2]], self.minis[minis[3]])
                if which:
                    self.store_top(bests, rv)

obj = BestWords()
obj.main()
