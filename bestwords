#!/usr/bin/env python3
"""TBD"""
# pylint: disable=invalid-name,too-many-branches,too-many-locals
# pylint: disable=too-many-nested-blocks

import os
import sys
from types import SimpleNamespace
import heapq

class Scorer:
    """Class for doing scoring computations"""
    scorer = None
    letters = {} # info on each letter
    grand_uniq_cnt = 0 # grand total of unique letters in words
    max_uniq_cnt = 0
    word_cnt = 0  # of answers

    def __init__(self):
        for letter in list('abcdefghijklmnopqrstuvwxyz'):
            self.letters[letter] = SimpleNamespace(
                    letter=letter,
                    pos_cnts=[0, 0, 0, 0, 0],
                    pos_mults=[0, 0, 0, 0, 0],
                    pos_sum=0,
                    uniq_cnt=0
                )

    @staticmethod
    def get_singleton():
        """TBD"""
        if not Scorer.scorer:
            Scorer.scorer = Scorer()
        return Scorer.scorer

    def add_word(self, word):
        """ Add a word to the scoring database."""
        seen = set()
        for pos, letter in enumerate(list(word)):
            ns = self.letters[letter]
            ns.pos_cnts[pos] += 1
            ns.pos_sum += 1
            if letter not in seen:
                seen.add(letter)
                ns.uniq_cnt += 1
                Scorer.grand_uniq_cnt += 1
        self.word_cnt += 1

    def freeze(self):
        """ Finish off scoring params. """
        Scorer.max_uniq_cnt = 0
        for ns in self.letters.values():
            if Scorer.max_uniq_cnt < ns.uniq_cnt:
                Scorer.max_uniq_cnt = ns.uniq_cnt
            for pos in range(5):
                mult = (ns.pos_cnts[pos] * 5) / ns.pos_sum
                mult = round(mult ** 0.33, 2) # take a root to compress numbers
                ns.pos_mults[pos] = mult

    def get_scores(self, word):
        """Get basic scord of word which is how many letters
        the work reveals"""
        raw_score = 0
        adj_score = 0
        for pos, letter in enumerate(list(word)):
            ns = self.letters[letter]
            score = int(round(1000*ns.uniq_cnt/Scorer.grand_uniq_cnt))
            raw_score += score
            ### give bonus for less popular letters
            ## score *= (2*Scorer.max_uniq_cnt - ns.uniq_cnt)/Scorer.max_uniq_cnt
            # give bonus for right position
            score *= ns.pos_mults[pos]
            adj_score += score

        return int(round(adj_score)), raw_score

    def dump(self, verbose):
        """Show the scoring stats"""
        print(f'{self.word_cnt} answer words; {Scorer.grand_uniq_cnt} unique letters')
        print('Showing for each letter:')
        print(' - % of all words w letter')
        print(' - % of words w letter having it in position (>100% reflects double-letters)')
        
        print('\nlet  pct   1  2  3  4  5  sum [position-pcts]')
        print(  '=== ====  == == == == ==  ===')

        nses = sorted(self.letters.values(), key= lambda ns: ns.uniq_cnt, reverse=True)
        for ns in nses:
            pcts = [int(round((100*cnt)/ns.uniq_cnt)) for cnt in ns.pos_cnts]
            pct_strs = [f'{pct:2d}' for pct in pcts]

            mults = [f'{mult:4.2f}' for mult in ns.pos_mults]
            mults_str = ' '.join(mults)
            out = f' {ns.letter}: {(100*ns.uniq_cnt)//Scorer.grand_uniq_cnt:3.1f}%'
            out += f'  {" ".join(pct_strs)} = {sum(pcts):3d}'
            if verbose:
                out += f'mults: {mults_str}'
            print(out)


class BestWords:
    """TBD"""
    def __init__(self):
        self.here = os.path.dirname(os.path.abspath(__file__)) # source directory
        self.opts = None
        self.answers = None
        self.guesses = None
        

    def get_word_lists(self, opts):
        """Read the word lists"""
        self.opts = opts
        self.answers = self._get_words(os.path.join(self.here, 'answers.txt'))
        self.guesses = self._get_words(os.path.join(self.here,'legal_words.txt'))
        self.guesses.update(self.answers)

    @staticmethod
    def overlapped(a, b):
        """Returns whether there is an overlap of two words."""
        return len(set(list(a) + list(b))) != len(a) + len(b)

    @staticmethod
    def get_overlap(a, b):
        """ number of overlapping letters in two words. """
        return len(set(list(a)) & set(list(b)))
        #rv = 0
        #for char in a:
            #if char in b:
                #rv += 1
        #return rv

    def _get_words(self, file_path):
        """This reads a set of words in a file into a list of words
        and into a set words (either the set of answers or legal guess)
        """
        words = {}
        scorer = Scorer.get_singleton() if 'answers' in file_path else None

        with open(file_path, "r", encoding='utf-8') as file:
            file_contents = file.read()
            lines = file_contents.splitlines()
            for line in lines:
                line = line.strip()
                if not line.startswith('#'):
                    wds = line.split()
                    for wd in wds:
                        words[wd] = None
                        if scorer:
                            scorer.add_word(wd)
        if self.opts.verbose:
            print(f'#words = {len(words)} in {file_path}')
        if scorer:
            scorer.freeze()
        return words

    def _get_germs(self, file_path):
        """This reads a set of words in a file into a list of words
        and into a set "germs" (or digests) that has the letters
        sorted and dups removed.  It also counts the number of
        letters used by all the words."""
        words = []
        germs = {}
        scorer = Scorer.get_singleton() if 'answers' in file_path else None

        with open(file_path, "r", encoding='utf-8') as file:
            file_contents = file.read()
            lines = file_contents.splitlines()
            for line in lines:
                line = line.strip()
                if not line.startswith('#'):
                    words += line.split()
        print(f'#words = {len(words)}')

        for word in words:
            if scorer:
                scorer.add_word(word)

            germ = set(list(word))
            germ = sorted(germ)
            germ = ''.join(germ)
            if germ in germs:
                germs[germ].append(word)
            else:
                germs[germ] = [word]
        print(f'#germs = {len(germs)}')
        return germs

    @staticmethod
    def store_top(results, item):
        """ This will store the top 30 items in a set of items. """
        if len(results) < 30:
            heapq.heappush(results, item)
        else:
            heapq.heappushpop(results, item)

    def get_some_fours(self, which):
        """TBD"""
        def get_scores(found):
            nonlocal self, scorer
            scores = [0]*8
            words = found.split()
            adj_score, raw_score = 0, 0
            used_letters = set()
            for idx, word in enumerate(words):
                subword = ''
                for letter in list(word):
                    if letter not in used_letters:
                        subword += letter
                        used_letters.add(letter)
                adj, raw = scorer.get_scores(subword)
                adj_score += adj
                raw_score += raw

                scores[idx] = adj_score
                scores[idx+4] = raw_score

            return (int(0.20*scores[0]
                    + 0.20*scores[1]
                    + 0.20*scores[2]
                    + 0.40*scores[3]), scores, found)

        groups = {}
        scorer = Scorer.get_singleton()
        for key in which:
            groups[key] = []

        # get all the possible sets of four words given the group of vowels
        # and the word set chosen. the 4 words will cover 20 letters because
        # each word must have 5 unique letters and use letters not covered
        # by the preceding words.

        # go thru the words in both the short an long dictionary and
        # save those if they have all the letters in the keys of "which"
        # (if they are in the right dictionary)

        for idx, word_dict in enumerate((self.answers, self.guesses)):
            for word in word_dict:
                for key, key_word_dict in which.items():
                    if key_word_dict != idx or len(word) < 5:
                        continue
                    if self.get_overlap(key, word) != len(key):
                        continue
                    if len(key) < 5 and self.get_overlap('aeiouy', word) != len(key):
                        continue
                    groups[key].append(word)

        for key, group in groups.items():
            print(f'{key} #{len(group)} {group[0:10]}')

        rv = []
        least_overlap = 1000
        word_groups = list(groups.values())
        last_pct = 0
        loops = len(word_groups[0])
        for idx, word0 in enumerate(word_groups[0]):
            for word1 in word_groups[1]:
                if self.overlapped(word0, word1):
                    continue
                for word2 in word_groups[2]:
                    if self.overlapped(word0+word1, word2):
                        continue
                    for word3 in word_groups[3]:
                        lap = self.get_overlap(word0+word1+word2, word3)
                        if lap > least_overlap:
                            continue
                        if lap < least_overlap:
                            if least_overlap > 2:
                                rv = []
                            least_overlap = lap
                        found = f'{word0} {word1} {word2} {word3}'
                        scores = get_scores(found)
                        self.store_top(rv, scores)
            pct = int(100*idx/loops)
            if pct > last_pct:
                # print(f'{pct}%')
                last_pct = pct
        return sorted(rv)

    def main(self):
        """TBD"""
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument('-s', '--stats-only', action='store_true',
                            help='show words stats only')
        parser.add_argument('-v', '--verbose', action='store_true',
                            help='show detail / debugging info')

        self.get_word_lists(parser.parse_args())

        Scorer.get_singleton().dump(self.opts.verbose)
        if self.opts.stats_only:
            return

        whichs = [
                # These are the sets of vowels we try
                # - the vowels must be alpabetical in each group/key
                # - the value is a tuple:
                #   - 0 means use legal answers; 1 means use legal guesses
                #   - 0,1,2,3 are the guess numbers
            # { 'a': 0 ,'ie': 0 ,'oy': 1 ,'u': 1 }, # winner
            # { 'a': 0 ,'ie': 0 ,'uy': 1 ,'o': 1 }, # 866 winner
            { 'a': 0 ,'ie': 0 ,'o': 1 ,'uy': 1 }, # 867 winner
            # { 'a': 0 ,'e': 0 ,'ui': 1 ,'oy': 1 }, # 813
            # { 'e': 0 ,'ia': 0 ,'uy': 1 ,'o': 1 }, # 820
            # { 'e': 0 ,'a': 0 ,'ui': 1 ,'oy': 1 }, # 818
            # { 'e': 0 ,'a': 0 ,'iy': 1 ,'ou': 1 }, # 816
            # { 'e': 0 ,'ai': 0 ,'oy': 1 ,'u': 1 }, # 821
            # { 'ae': 0 ,'iu': 0 ,'y': 1 ,'o': 1 }, # 826
            # { 'ae': 0 ,'io': 0 ,'y': 1 ,'u': 1 }, # 835
            # { 'aei': 1 ,'o': 0 ,'y': 1 ,'u': 1 }, # 837
            # { 'eo': 0 ,'ai': 0 ,'y': 1 ,'u': 1 }, # 823
            # { 'e': 0 ,'a': 0 ,'iy': 1 ,'ou': 1 }, # 816
        ]
        bests = []
        # this loop prints out the top 30 for each vowel set above,
        # and then the top 30 overall
        for which in whichs + [None]:
            rvs = self.get_some_fours(which) if which else sorted(bests)
            print(f'\n====== {which}')
            for rv in rvs:
                words = rv[2].split()
                cnt = len(set(list(''.join(words))))
                print(rv[0], rv[1][0:4], rv[1][4:], words[0],
                    words[1], words[2], words[3], f'/{cnt}')
                if which:
                    self.store_top(bests, rv)

obj = BestWords()
obj.main()
