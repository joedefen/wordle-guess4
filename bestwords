#!/usr/bin/env python3
"""TBD"""
# pylint: disable=invalid-name,too-many-branches,too-many-locals
# pylint: disable=too-many-nested-blocks

import os
import sys
from types import SimpleNamespace
import heapq

class Scorer:
    """Class for doing scoring compuations"""
    scorer = None
    letters = {}
    grand_uniq_cnt = 0
    word_cnt = 0

    def __init__(self):
        for letter in list('abcdefghijklmnopqrstuvwxyz'):
            self.letters[letter] = SimpleNamespace(
                    letter=letter,
                    pos_cnts=[0, 0, 0, 0, 0],
                    pos_sum=0,
                    uniq_cnt=0
                )

    @staticmethod
    def get_singleton():
        """TBD"""
        if not Scorer.scorer:
            Scorer.scorer = Scorer()
        return Scorer.scorer

    def add_word(self, word):
        """ Add a word to the scoring database."""
        seen = set()
        for pos, letter in enumerate(list(word)):
            ns = self.letters[letter]
            ns.pos_cnts[pos] += 1
            ns.pos_sum += 1
            if letter not in seen:
                seen.add(letter)
                ns.uniq_cnt += 1
                Scorer.grand_uniq_cnt += 1
        self.word_cnt += 1
        
    def raw_score(self, word):
        score = 0
        for pos, letter in enumerate(set(list(word))):
            ns = self.letters[letter]
            score += ns.uniq_cnt
        return score

    def dump(self):
        """Show the scoring stats"""
        print(f'{self.word_cnt} words; {Scorer.grand_uniq_cnt} unique letters')

        nses = sorted(self.letters.values(), key= lambda ns: ns.uniq_cnt, reverse=True)
        for ns in nses:
            freqs = [f'{(100*cnt)//ns.uniq_cnt:2d}' for cnt in ns.pos_cnts]
            freqs_str = ' '.join(freqs)
            print(f'{ns.letter}: {(1000*ns.uniq_cnt)//Scorer.grand_uniq_cnt:3d} pct: {freqs_str}')


class BestWords:
    """TBD"""
    def __init__(self):
        here = os.path.dirname(os.path.abspath(__file__)) # source directory
        self.total_letters = 0
        self.short_germs = self._get_germs(os.path.join(here, 'answers.txt'))
        self.total_short, self.total_letters = self.total_letters, 0
        self.germs = self._get_germs(os.path.join(here,'legal_words.txt'))
        for germ, values in self.short_germs.items():
            if germ in self.germs:
                self.germs[germ] += values
            else:
                self.germs[germ] = values
        self.total_letters += self.total_short
        self.uniq_germs = [germ for germ in self.germs if len(germ)==5]
        self.uniq_shorts = [germ for germ in self.short_germs if len(germ)==5]
        print(f'#uniq = {len(self.uniq_germs)}')

    @staticmethod
    def overlapped(a, b):
        """Returns whether there is an overlap of two words."""
        return len(set(list(a) + list(b))) != len(a) + len(b)

    @staticmethod
    def get_overlap(a, b):
        """ number of overlapping letters in two words. """
        return len(set(list(a)) & set(list(b)))
        #rv = 0
        #for char in a:
            #if char in b:
                #rv += 1
        #return rv

    def _get_germs(self, file_path):
        """This reads a set of words in a file into a list of words
        and into a set "germs" (or digests) that has the letters
        sorted and dups removed.  It also counts the number of
        letters used by all the words."""
        words = []
        germs = {}
        scorer = Scorer.get_singleton() if 'answers' in file_path else None

        with open(file_path, "r", encoding='utf-8') as file:
            file_contents = file.read()
            lines = file_contents.splitlines()
            for line in lines:
                line = line.strip()
                if not line.startswith('#'):
                    words += line.split()
        print(f'#words = {len(words)}')

        for word in words:
            if scorer:
                scorer.add_word(word)

            germ = set(list(word))
            germ = sorted(germ)
            germ = ''.join(germ)
            if germ in germs:
                germs[germ].append(word)
            else:
                germs[germ] = [word]
            self.total_letters += len(germ)
        print(f'#germs = {len(germs)}')
        # total_letters = 5*len(germs)
        return germs

    @staticmethod
    def store_top(results, item):
        """ This will store the top 30 items in a set of items. """
        if len(results) < 30:
            heapq.heappush(results, item)
        else:
            heapq.heappushpop(results, item)

    def get_some_fours(self, which):
        """TBD"""
        def get_scores(found):
            nonlocal self, scorer
            scores = []
            words = found.split()
            score = 0
            used_letters = set()
            for word in words:
                subword = ''
                for letter in list(word):
                    if letter not in used_letters:
                        subword += letter
                        used_letters.add(letter)
                score += scorer.raw_score(subword)
                scores.append(int(1000*score/self.total_short))

            return (int(0.05*scores[0]
                    + 0.10*scores[1]
                    + 0.15*scores[2]
                    + 0.7*scores[3]), scores, found)

        groups = {}
        scorer = Scorer.get_singleton()
        for key in which:
            groups[key] = []

        # get all the possible sets of four words given the group of vowels
        # and the word set chosen. the 4 words will cover 20 letters because
        # each word must have 5 unique letters and use letters not covered
        # by the preceding words.

        # go thru the words in both the short an long dictionary and
        # save those if they have all the letters in the keys of "which"
        # (if they are in the right dictionary)

        for idx, word_dict in enumerate((self.uniq_shorts, self.uniq_germs)):
            for germ in word_dict:
                for key, key_word_dict in which.items():
                    if key_word_dict != idx:
                        continue
                    if self.get_overlap(key, germ) != len(key):
                        continue
                    if len(key) < 5 and self.get_overlap('aeiouy', germ) != len(key):
                        continue
                    groups[key].append(germ)

        for key, group in groups.items():
            print(f'{key} #{len(group)} {group[0:10]}')

        rv = []
        least_overlap = 1000
        germs = list(groups.values())
        last_pct = 0
        loops = len(germs[0])
        for idx, germ0 in enumerate(germs[0]):
            for germ1 in germs[1]:
                if self.overlapped(germ0, germ1):
                    continue
                for germ2 in germs[2]:
                    if self.overlapped(germ0+germ1, germ2):
                        continue
                    for germ3 in germs[3]:
                        lap = self.get_overlap(germ0+germ1+germ2, germ3)
                        if lap > least_overlap:
                            continue
                        if lap < least_overlap:
                            if least_overlap > 2:
                                rv = []
                            least_overlap = lap
                        found = f'{germ0} {germ1} {germ2} {germ3}'
                        scores = get_scores(found)
                        self.store_top(rv, scores)
            pct = int(100*idx/loops)
            if pct > last_pct:
                # print(f'{pct}%')
                last_pct = pct
        return sorted(rv)

    def main(self):
        """TBD"""

        whichs = [
                # These are the sets of vowels we try
                # - the vowels must be alpabetical in each group/key
                # - the value is a tuple:
                #   - 0 means use legal answers; 1 means use legal guesses
                #   - 0,1,2,3 are the guess numbers
            { 'ae': 0 ,'iu': 0 ,'y': 1 ,'o': 1 },
            { 'ae': 0 ,'io': 0 ,'y': 1 ,'u': 1 }, # winner
            { 'aei': 1 ,'o': 0 ,'y': 1 ,'u': 1 },
            { 'eo': 0 ,'ai': 0 ,'y': 1 ,'u': 1 },
            { 'e': 0 ,'a': 0 ,'iy': 1 ,'ou': 1 },
            ## { 'parse': 1, 'clint': 1, 'oy': 1, 'u': 1 },
            ## { 'scale': 1, 'print': 1, 'oy': 1, 'u': 1 },
            { 'slant': 1, 'crime': 1, 'oy': 1, 'u': 1 },
            { 'slant': 1, 'crime': 1, 'o': 1, 'yu': 1 },
            { 'slant': 1, 'crime': 1, 'y': 1, 'ou': 1 },
            { 'slant': 1, 'crime': 1, 'o': 1, 'y': 1 },
        ]
        bests = []
        # this loop prints out the top 30 for each vowel set above,
        # and then the top 30 overall
        for which in whichs + [None]:
            rvs = self.get_some_fours(which) if which else sorted(bests)
            print(f'\n====== {which}')
            for rv in rvs:
                germs = rv[2].split()
                print(rv[0], rv[1], self.germs[germs[0]],
                    self.germs[germs[1]], self.germs[germs[2]], self.germs[germs[3]])
                if which:
                    self.store_top(bests, rv)

obj = BestWords()
Scorer.get_singleton().dump()
obj.main()
